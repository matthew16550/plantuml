name: Ensure snapshot release is up to date

#on:
#  #  push:
#  #    branches: [ snapshot-release-2 ]
#  workflow_call:
#  workflow_dispatch:
#  workflow_run:
#    workflows: [ CI ]
#    branches: [ snapshot-release-2 ]
#    types: [ completed ]

#concurrency:
#  group: snapshot_release

#jobs:
#  snapshot_release:
#    runs-on: ubuntu-latest
runs:
  using: "composite"
  steps:
    - name: debug
      env:
        EVENT: ${{ toJSON(github.event) }}
      shell: bash
      run: echo "${EVENT}"

    - name: Configure job
      id: config
      uses: actions/github-script@v5
      with:
        script: |
          const RELEASE_BRANCH = "snapshot-release-2"

          core.info("Finding current snapshot ...")

          const currentSnapshot = (
          		await github.graphql(`
          			query ($owner: String!, $repo: String!) {
          			  repository(owner: $owner, name: $repo) {
          				release(tagName: "snapshot") {
                            url
          				  tagCommit {
          					committedDate
          					oid
          			} } } } `, context.repo
          		)
          ).repository.release

          const snapshotSha = currentSnapshot ? currentSnapshot.tagCommit.oid : null

          core.info(`Current snapshot: ${snapshotSha || "NONE"}`)

          core.info(`Finding newest commits ...`)

          const commits = (
          		await github.graphql(`
          			query($owner: String!, $repo: String!, $head: String!, $since: GitTimestamp!) {
          			  repository(owner: $owner, name: $repo) {
          				object(expression: $head) {
          				  ... on Commit {
          					history(first: 100, since: $since) {
          					  edges {
          						node {
                                    message
          						  oid
          						  url
          						  checkSuites(first: 100) {
          							nodes {
          							  conclusion
          							  workflowRun {
          								databaseId
          								runNumber
          								url
          								workflow {
          								  name
          			} } } } } } } } } } }`,
          				{
          					...context.repo,
          					head: `refs/heads/${RELEASE_BRANCH}`,
          					since: currentSnapshot ? currentSnapshot.tagCommit.committedDate : "1970-01-01T00:00:00Z",
          				}
          		)
          ).repository.object.history.edges.map(edge => edge.node)

          for (let commit of commits) {
          	core.info(`Considering ${commit.url}`)

          	if (snapshotSha && snapshotSha === commit.oid) {
          		core.notice(`Snapshot is already at the newest possible commit ${currentSnapshot.url}`)
          		return
          	}

          	if (commit.message.startsWith("[maven-release-plugin] prepare release ")) {
          		core.info("Ignoring release commit")
          		continue
          	}

          	for (let suite of commit.checkSuites.nodes) {
          		const run = suite.workflowRun
          		if (run && run.workflow.name === "CI" && suite.conclusion === "SUCCESS") {
          			core.notice(`Updating to run #${run.runNumber} ${run.url}\n(commit ${commit.url})`)
          			core.setOutput("sha", commit.oid);
                      if (run.databaseId == context.runId && == run.runNumber == context.runNumber) {
          			  core.setOutput("download_from_this_run", true);
                      } else {
                        core.setOutput("artifact_name", `${run.runNumber}-jars`);
                        core.setOutput("run_id", run.databaseId);
                      }
          			return
          		}
          	}
          }

          // We could look at more commits by paging the history() query but it should never be relevant so not implemented
          core.warning(`Nothing found from ${commits.length} newest commits`)

    - name: Checkout the repository
      if: steps.config.outputs.sha
      uses: actions/checkout@v2
      with:
        ref: ${{ steps.config.outputs.sha }}

    - name: Download jars from another run
      if: steps.config.outputs.run_id
      env:
        ARTIFACT_NAME: ${{ steps.config.outputs.artifact_name }}
        GITHUB_TOKEN: ${{ github.token }}
        RUN_ID: ${{ steps.config.outputs.run_id }}
      shell: bash
      run: gh run download "${RUN_ID}" -n "${ARTIFACT_NAME}"

    - name: Download jars from this run
      if: steps.config.outputs.download_from_this_run
      uses: actions/download-artifact@v2
      with:
        name: ${{ github.run_number }}-jars

    - name: Create release
      if: steps.config.outputs.sha
      env:
        GITHUB_TOKEN: ${{ github.token }}
        RELEASE_VERSION: SNAPSHOT
        RELEASE_SHA: ${{ steps.config.outputs.sha }}
        TAG: snapshot
      shell: bash
      run: |
        set -x

        cat <<-EOF >release-notes.txt
          This is a pre-release of the latest development work.
          ⚠️  **It is not ready for general use** ⚠️
          ⏱  _Snapshot taken $(date -u +"%F at %T (UTC)")_
        EOF

        gh release delete "${TAG}" || true
        git push --delete origin "${TAG}" || true
        git tag --delete "${TAG}" || true

        mv plantuml.jar         "plantuml-${RELEASE_VERSION}.jar"
        mv plantuml-javadoc.jar "plantuml-${RELEASE_VERSION}-javadoc.jar"
        mv plantuml-sources.jar "plantuml-${RELEASE_VERSION}-sources.jar"

        gh release create --prerelease --target "${RELEASE_SHA}" --title "${TAG}" --notes-file release-notes.txt "${TAG}" \
          "plantuml-${RELEASE_VERSION}.jar" \
          "plantuml-${RELEASE_VERSION}-javadoc.jar" \
          "plantuml-${RELEASE_VERSION}-sources.jar"

        echo "::notice title=::Snapshot released at ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
